# **布隆过滤器**

- 讲个使用场景，比如在使用新闻客户端看新闻时，它会给我们不停地推荐新的内容，它每次推荐时要**去重**，去掉那些已经看过的内容。问题来了，**新闻客户端推荐系统如何实现推送去重的**？

- 你会想到**服务器记录了用户看过的所有历史记录**，当推荐系统推荐新闻时会从每个用户的历史记录里进行筛选，过滤掉那些已经存在的记录。问题是当**用户量很大**，每个用户看过的新闻又很多的情况下，这种方式，推荐系统的去重工作在性能上跟的上么?

- 你可能又想到了**缓存**，但是如此多的历史记录全部缓存起来，会浪费较大的存储空间，而且这个存储空间是随着时间线性增长。

## **布隆过滤器是什么?**
- 布隆过滤器可以理解为一个不怎么精确的 set 结构，**当你使用它的 contains 方法判断某个对象是否存在时，它可能会误判**。
- 当布隆过滤器说某个值存在时，这个值**可能不存在**；当它说不存在时，那就**肯定不存在**。
- 套在上面的使用场景中，布隆过滤器能**准确过滤掉那些已经看过的内容**，那些**没有看过的新内容**，它也会过滤掉极小一部分(误判)，但是绝大多数新内容它都能准确识别。这样就 可以完全保证推荐给用户的内容都是**无重复**的。

## **布隆过滤器基本使用**
- 布隆过滤器有二个基本指令，bf.add 添加元素，bf.exists 查询元素是否存在，它的用法和 set 集合的 sadd 和 sismember 差不多。
```bash
127.0.0.1:6379> bf.add codehole user1 
(integer) 1
127.0.0.1:6379> bf.add codehole user2 
(integer) 1
127.0.0.1:6379> bf.add codehole user3 
(integer) 1
127.0.0.1:6379> bf.exists codehole user1 
(integer) 1
127.0.0.1:6379> bf.exists codehole user2 
(integer) 1
127.0.0.1:6379> bf.exists codehole user3 
(integer) 1
127.0.0.1:6379> bf.exists codehole user4
(integer) 0
127.0.0.1:6379> bf.madd codehole user4 user5 user6
1) (integer) 1
2) (integer) 1
3) (integer) 1
127.0.0.1:6379> bf.mexists codehole user4 user5 user6 user7 
1) (integer) 1
2) (integer) 1
3) (integer) 1
4) (integer) 0
```

- 默认参数的布隆过滤器，在第一次 add 的时候**自动创建**。
- Redis 其实还提供了**自定义参数**的布隆过滤器，需要在 add 之前使用 **bf.reserve** 指令显式创建。
- 如果对应的 key 已经存在，bf.reserve 会报错。bf.reserve 有三个参数，分别是 **key, error_rate 和 initial_size**。
- **错误率越低，需要的空间越大**。initial_size 参数表示预计放入的元素数量，当实际数量**超出这个数值时，误判率会上升**。
- 所以需要提前设置一个**较大的数值避免超出导致误判率升高**。如果不使用 bf.reserve，默认的 error_rate 是 0.01，默认的 initial_size 是 100。

## **注意事项**
- 布隆过滤器的 initial_size 估计的过大，会浪费存储空间，估计的过小，就会影响准确率，在使用之前一定要尽可能地**精确估计好元素数量**，还需要加上一定的**冗余空间**以避免实际元素可能会意外高出估计值很多。