# **缓存更新的套路**

> 参考: https://coolshell.cn/articles/17416.html

## **缓存三种模式**

一般来说，缓存有以下三种模式：

- Cache Aside 更新模式
- Read/Write Through 更新模式
- Write Behind Caching 更新模式

## **I. Cache Aside Pattern**

这是最常用最常用的 pattern 了。其具体逻辑如下：

- **失效**：应用程序先从 cache 取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。
- **命中**：应用程序从 cache 中取数据，取到后返回。
- **更新**：先把数据存到数据库中，成功后，再让缓存失效。

这是标准的 design pattern，包括 Facebook 的论文 [Scaling Memcache at Facebook](https://www.usenix.org/system/files/conference/nsdi13/nsdi13-final170_update.pdf) 也使用了这个策略。为什么不是写完数据库后更新缓存？，主要是怕**两个并发的写操作导致脏数据**。

### **避坑指南一**

- **先更新数据库，再更新缓存。这种做法最大的问题就是两个并发的写操作导致脏数据**。两个并发更新操作，数据库**先更新的反而后更新缓存**，数据库**后更新的反而先更新缓存**。这样就会造成**数据库和缓存中的数据不一致**，应用程序中读取的都是脏数据。

### **避坑指南二**

- **先删除缓存，再更新数据库。而后续的读操作会把数据再装载的到缓存中。这个逻辑是错误的，因为两个并发的读和写操作导致脏数据**。试想，两个并发操作，一个是更新操作，另一个是查询操作，**更新操作删除缓存后，查询操作没有命中缓存，先把老数据读出来后放到缓存中，然后更新操作更新了数据库**。于是，在缓存中的数据还是老的数据，导致缓存中的数据是脏的，而且还一直这样脏下去了。

### **避坑指南三**

- 那么，是不是 Cache Aside 这个就不会有并发问题了？不是的，比如，一个是**读操作，但是没有命中缓存**，然后就到数据库中取数据，此时来了一个写操作，写完数据库后，**让缓存失效**，然后，之前的**那个读操作再把老的数据放进去**，所以，会造成脏数据。

    但，这个 case 理论上会出现，不过，实际上出现的概率可能非常低，因为这个条件需要发生在**读缓存时缓存失效，而且并发着有一个写操作**。而实际上数据库的**写操作会比读操作慢得多，而且还要锁表，而读操作必需在写操作前进入数据库操作，而又要晚于写操作更新缓存**，所有的这些条件都具备的概率基本并不大。

## **II. Read/Write Through Pattern**

我们可以看到，在上面的 Cache Aside 套路中，我们的应用代码需要维护**两个数据存储**，一个是缓存（Cache），一个是数据库（Repository）。所以，应用程序比较啰嗦。而 Read/Write Through 套路是把更新数据库（Repository）的操作由缓存自己代理了，所以，对于应用层来说，就简单很多了。可以理解为，**应用认为后端就是一个单一的存储，而存储自己维护自己的 Cache**。

### **Read Through**

Read Through 套路就是在查询操作中更新缓存，也就是说，当**缓存失效的时候（过期或 LRU 换出）**，Cache Aside 是由**调用方负责把数据加载入缓存**，而 Read Through 则**用缓存服务自己来加载**，从而对调用方是透明的。

### **Write Through**

Write Through 套路和 Read Through 相仿，不过是在更新数据时发生。当有数据更新的时候，如果没有命中缓存，**直接更新数据库**，然后返回。如果命中了缓存，则**更新缓存，然后再由 Cache 自己更新数据库**（这是一个同步操作）。

## **III. Write Behind Caching Pattern**

Write Behind 又叫 Write Back。类似 Linux 文件系统的 Page Cache 的算法。

Write Back 套路，一句说就是，**在更新数据的时候，只更新缓存，不更新数据库**，而我们的缓存会**异步地批量更新数据库**。这个设计的好处就是让数据的 I/O 操作飞快无比（因为直接操作内存），因为异步，write back 还可以合并对同一个数据的多次操作，所以性能的提高是相当可观的。

但是，其带来的问题是，**数据不是强一致性的，而且可能会丢失**（我们知道 Unix/Linux 非正常关机会导致数据丢失，就是因为这个事）。在软件设计上，我们基本上不可能做出一个没有缺陷的设计，就像算法设计中的时间换空间，空间换时间一个道理，有时候，强一致性和高性能，高可用和高性性是有冲突的。软件设计从来都是取舍 Trade-Off。

另外，Write Back 实现逻辑比较复杂，因为他**需要 track 有哪数据是被更新了的，需要刷到持久层上**。操作系统的 write back 会在**仅当这个 cache 需要失效的时候，才会被真正持久起来**，比如，内存不够了，或是进程退出了等情况，这又叫 lazy write。

## **再多唠叨一些**

1. 上面讲的这些 Design Pattern，其实并不是软件架构里的 mysql 数据库和 memcache/redis 的更新策略，这些东西都是**计算机体系结构里的设计**，比如 CPU 的缓存，硬盘文件系统中的缓存，硬盘上的缓存，数据库中的缓存。基本上来说，**这些缓存更新的设计模式都是非常老古董的，而且历经长时间考验的策略**，所以这也就是，**工程学上所谓的 Best Practice**，遵从就好了。

2. 有时候，我们觉得能做宏观的系统架构的人一定是很有经验的，其实，**宏观系统架构中的很多设计都来源于这些微观的东西**。比如，云计算中的很多虚拟化技术的原理，和传统的虚拟内存不是很像么？**Unix 下的那些 I/O 模型，也放大到了架构里的同步异步的模型**，**还有 Unix 发明的管道不就是数据流式计算架构吗**？**TCP 的好些设计也用在不同系统间的通讯中**，仔细看看这些微观层面，你会发现有很多设计都非常精妙... 所以，请允许我在这里放句观点鲜明的话——**如果你要做好架构，首先你得把计算机体系结构以及很多老古董的基础技术吃透了**。

3. 在软件开发或设计中，我非常建议在之前先去**参考一下已有的设计和思路**，看看相应的 guideline，best practice 或 design pattern，吃透了已有的这些东西，再决定是否要重新发明轮子。千万不要似是而非地，想当然的做软件设计。

4. 上面，我们没有考虑**缓存（Cache）和持久层（Repository）的整体事务**的问题。比如，**更新 Cache 成功，更新数据库失败了**怎么办？或是反过来。关于这个事，如果你需要强一致性，你需要使用“两阶段提交协议”—— prepare, commit/rollback，比如Java 7 的 [XAResource](https://docs.oracle.com/javaee/7/api/javax/transaction/xa/XAResource.html)，还有 MySQL 5.7 的 [XA Transaction](https://dev.mysql.com/doc/refman/5.7/en/xa.html)，有些 cache 也支持 XA，比如 [EhCache](http://www.ehcache.org/documentation/3.0/xa.html)。当然，XA 这样的强一致性的玩法会导致性能下降，关于分布式的事务的相关话题，你可以看看《分布式系统的事务处理》一文。