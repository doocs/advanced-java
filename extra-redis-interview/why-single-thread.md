# **为什么Redis是单线程的**

> 参考: https://zhuanlan.zhihu.com/p/52600663  
> 参考：https://mp.weixin.qq.com/s/f9N13fnyTtnu2D5sKZiu9w

本质上Redis并不是**单纯的单线程服务模型**，一些辅助工作比如**持久化刷盘、惰性删除**等任务是由 **BIO 线程 (???)**来完成的，这里说的单线程主要是说**与客户端交互完成命令请求和回复**的工作线程。

## **I.官方答案**

因为 Redis 是**基于内存**的操作，**CPU 不是 Redis 的瓶颈**，Redis 的瓶颈最有可能是**机器内存的大小或者网络带宽**。既然单线程容易实现，而且 CPU 不会成为瓶颈，那就顺理成章地采用单线程的方案了。

------------------

## **II. 单线程模式的考量**

- **CPU 并非瓶颈**：多线程模型主要是为了**充分利用多核 CPU**，让线程在 IO 阻塞时被挂起让出 CPU 使用权交给其他线程，充分提高 CPU 的使用率，但是这个场景在Redis并不明显，因为 **CPU 并不是 Redis 的瓶颈**，Redis 的所有操作都是基于内存的，处理事件极快，因此使用多线程来切换线程提高 CPU 利用率的需求并不强烈；

- **内存才是瓶颈**：单个 Redis 实例对单核的利用已经很好了，但是 Redis 的瓶颈在于内存，设想64核的机器假如内存只有 16GB，那么多线程 Redis 有什么用武之地？

- **复杂的Value类型**：Redis 有**丰富的数据结构**，并不是简单的 Key-Value 型的 NoSQL，这也是 Redis 备受欢迎的原因，其中常用的 Hash、Zset、List 等结构在 value 很大时，**CURD 的操作会很复杂**，如果采用多线程模式在进行相同 key 操作时就需要**加锁来进行同步**，这样就可能造成死锁问题。

    **这时候你会问**：将 key 做 hash 分配给相同的线程来处理就可以解决呀，确实是这样的，这样的话就需要在 Redis 中增加 **key 的 hash 处理**以及**多线程负载均衡**的处理，从而 Redis 的实现就成为多线程模式了，好像确实也没有什么问题，但是 Antirez 并没有这么做，大神这么做肯定是有原因的，果不其然，我们见到了**集群化的 Redis**；

- **集群化扩展**：目前的机器都是多核的，但是内存一般 128GB/64GB 算是比较普遍了，但是 Redis 在使用内存 60% 以上稳定性就不如 50% 的性能了(至少笔者在使用集群化 Redis 时超过 70% 时，集群 failover 的频率会更高)，因此在数据较大时，当 Redis 作为主存，就必须使用**多台机器**构建集群化的 Redis 数据库系统，这样以来 Redis 的单线程模式又被**集群化**的处理所扩展了；

- **软件工程角度**：单线程无论从**开发和维护都比多线程要容易非常多**，并且也能提高**服务的稳定性**，**无锁化处理**让单线程的 Redis 在开发和维护上都具备相当大的优势；

------------------

## **III. 注意**

这里我们一直在强调的单线程，只是**在处理网络请求的时候只有一个线程来处理**，一个正式的 Redis Server 运行的时候肯定是不止一个线程的，这里需要大家明确的注意一下！例如 **Redis 进行持久化的时候会以子进程或者子线程的方式执行**（具体是子线程还是子进程待读者深入研究）；

我们知道 Redis 是用 "**单线程-多路复用IO模型 (???)**" 来实现高性能的内存数据服务的，这种机制避免了使用锁，但是同时这种机制**在进行 sunion 之类的比较耗时的命令时会使 redis 的并发下降**。因为是单一线程，所以同一时刻只有一个操作在进行，所以，耗时的命令会导致并发的下降，不只是读并发，写并发也会下降。而单一线程也只能用到一个 CPU 核心，所以可以在同一个多核的服务器中，可以启动多个实例，组成 master-master 或者 master-slave 的形式，耗时的读命令可以完全在 slave 进行。